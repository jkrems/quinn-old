// Generated by LiveScript 1.2.0
var glob, path, readFileSync, swig, helpers, ref$, promisedBlocks, resolvePromisedBlocks, whenHelper, cacheTemplates, allowTemplateErrors, templateInfo, templates, _modules, templateError, swig__compileFile, render, addTemplate, loadTemplates, slice$ = [].slice;
glob = require('glob');
path = require('path');
readFileSync = require('fs').readFileSync;
swig = require('swig');
helpers = require('swig/lib/helpers');
ref$ = require('./render/deferred-renderer'), promisedBlocks = ref$.promisedBlocks, resolvePromisedBlocks = ref$.resolvePromisedBlocks, whenHelper = ref$.whenHelper;
cacheTemplates = false;
allowTemplateErrors = false;
templateInfo = {};
templates = {};
_modules = {};
templateError = function(error){
  return {
    render: function(){
      return "<pre>" + error.stack + "</pre>";
    }
  };
};
swig__compileFile = swig.compileFile;
swig.compileFile = function(templateName, forceAllowErrors){
  var get, e;
  templateName = templateName.replace(/\/index$/, '');
  if (cacheTemplates && templates.hasOwnProperty(templateName)) {
    return templates[templateName];
  }
  get = function(){
    var ref$, moduleName, segments, module, dirname, filename, tryFilename, err;
    ref$ = templateName.split('/'), moduleName = ref$[0], segments = slice$.call(ref$, 1);
    module = _modules[moduleName];
    if (module == null) {
      throw new Error("Unknown module: " + moduleName);
    }
    dirname = path.join.apply(path, [module.directory, 'templates'].concat(slice$.call(segments)));
    filename = dirname + '.html';
    tryFilename = function(filename){
      var compiled;
      compiled = swig__compileFile(filename, forceAllowErrors);
      addTemplate(templateName, {
        filename: filename,
        compiled: compiled
      });
      return compiled;
    };
    try {
      return tryFilename(filename);
    } catch (e$) {
      err = e$;
      if (err.code !== 'ENOENT') {
        throw err;
      }
      return tryFilename(dirname + '/index.html');
    }
  };
  if (allowTemplateErrors || forceAllowErrors) {
    return get();
  } else {
    try {
      return get();
    } catch (e$) {
      e = e$;
      return templateError(e);
    }
  }
};
swig.init({
  root: __dirname + '/swigs',
  cache: cacheTemplates,
  allowErrors: true,
  tags: {
    when: whenHelper,
    assetUrl: function(indent, parser){
      return [helpers.setVar('__file', parser.parseVariable(this.args[0])), '_output += __file;'].join('');
    },
    jsUrl: function(indent, parser){
      return [helpers.setVar('__file', parser.parseVariable(this.args[0])), '_output += __file;'].join('');
    },
    pathTo: function(indent, parser){
      return [helpers.setVar('__path', parser.parseVariable(this.args[0])), '_output += __path;'].join('');
    },
    route: function(indent, parser){
      var ref$, routeStr, opts, output, log;
      ref$ = this.args, routeStr = ref$[0], opts = ref$[1];
      output = [];
      if (opts != null) {
        if (opts === 'true' || opts === 'false' || /^\{|^\[/.test(opts) || helpers.isLiteral(opts)) {
          console.log(opts);
          output.push("var __opts = " + opts + ";");
        } else {
          output.push(helpers.setVar('__opts', parser.parseVariable(opts)));
        }
      } else {
        output.push('var __opts = {};');
      }
      log = function(str){
        console.log(str);
        return str;
      };
      return output.concat([helpers.setVar('__r', parser.parseVariable(routeStr)), '_output += _context.router.reverseRoute(["GET"], __r, __opts);']).join('');
    }
  },
  extensions: {
    promisedBlock: promisedBlock
  },
  filters: {
    pathTo: function(input){
      return input;
    },
    assetUrl: function(input){
      return input;
    },
    _t: function(input, opts){
      return input + JSON.stringify(opts);
    }
  }
});
render = function(templateName, context, options){
  var template, rendered, ref$;
  context == null && (context = {});
  options == null && (options = {});
  template = swig.compileFile(templateName);
  if (template == null) {
    throw new Error("Template not found: " + templateName);
  }
  rendered = template.render(context);
  return {
    status: (ref$ = options.status) != null ? ref$ : 200,
    headers: {
      'Content-Type': 'text/html; charset=utf-8'
    },
    body: resolvePromisedBlocks(rendered, options)
  };
};
addTemplate = function(name, template){
  templates[name] = template.compiled;
  templateInfo[name] = template;
  return template;
};
loadTemplates = function(modules){
  return _modules = modules.reduce(function(acc, module){
    acc[module.name] = module;
    return acc;
  }, {});
};
render.addTemplate = addTemplate;
render.loadTemplates = loadTemplates;
module.exports = render;