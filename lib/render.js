// Generated by LiveScript 1.2.0
var glob, readFileSync, swig, Duplex, helpers, uuid, promisedBlocks, promisedBlock, ResolveTemplateStream, whenHelper, templateInfo, templates, render, addTemplate, loadTemplates;
glob = require('glob');
readFileSync = require('fs').readFileSync;
swig = require('swig');
Duplex = require('stream').Duplex;
helpers = require('swig/lib/helpers');
uuid = require('node-uuid');
promisedBlocks = {};
promisedBlock = function(promise, fn, name){
  var kindaUniq;
  kindaUniq = "<!--Q:$" + uuid.v4() + "-->";
  promisedBlocks[kindaUniq] = {
    promise: promise,
    fn: fn,
    name: name
  };
  return kindaUniq;
};
ResolveTemplateStream = (function(superclass){
  var prototype = extend$((import$(ResolveTemplateStream, superclass).displayName = 'ResolveTemplateStream', ResolveTemplateStream), superclass).prototype, constructor = ResolveTemplateStream;
  function ResolveTemplateStream(_buffer, opts){
    var ref$;
    this._buffer = _buffer;
    opts == null && (opts = {});
    this._nextBlock = null;
    this._timeout = (ref$ = opts.timeout) != null ? ref$ : 2000;
    ResolveTemplateStream.superclass.call(this, opts);
  }
  prototype._getNextBlock = function(){
    var block, markerIdx, skipped, markerEnd, marker;
    if (this._nextBlock != null) {
      block = this._nextBlock;
      this._nextBlock = null;
      return {
        skipped: '',
        block: block
      };
    } else {
      markerIdx = this._buffer.indexOf('<!--Q:$');
      if (markerIdx === -1) {
        skipped = this._buffer;
        this._buffer = '';
        return {
          skipped: skipped,
          block: null
        };
      } else {
        skipped = this._buffer.substr(0, markerIdx);
        markerEnd = this._buffer.indexOf('-->', markerIdx) + 3;
        if (markerIdx === -1) {
          throw new Error('Unclosed marker in deferred template');
        }
        marker = this._buffer.substring(markerIdx, markerEnd);
        this._buffer = this._buffer.substr(markerEnd);
        block = promisedBlocks[marker];
        if (block == null) {
          throw new Error("Invalid block id: " + marker);
        }
        return {
          skipped: skipped,
          block: block
        };
      }
    }
  };
  prototype._read = function(){
    var ref$, skipped, block, promise, fn, state, value, reason, this$ = this;
    this._timer == null && (this._timer = setTimeout(function(){
      var waitedFor, ref$, ref1$, err;
      if (this$._nextBlock != null || this$._buffer !== '') {
        waitedFor = (ref$ = (ref1$ = this$._nextBlock) != null ? ref1$.name : void 8) != null ? ref$ : '<unknown>';
        err = new Error("Rendering timed out while waiting for " + waitedFor);
        err.renderBuffer = this$._buffer;
        this$.emit('error', err);
        this$.push(null);
      }
      this$._nextBlock = null;
      return this$._buffer = '';
    }, this._timeout));
    if (this._buffer === '') {
      clearTimeout(this._timer);
      this.push(null);
    }
    ref$ = this._getNextBlock(), skipped = ref$.skipped, block = ref$.block;
    if (skipped !== '') {
      this.push(skipped);
    }
    if (block != null) {
      promise = block.promise, fn = block.fn;
      ref$ = promise.inspect(), state = ref$.state, value = ref$.value, reason = ref$.reason;
      switch (state) {
      case 'pending':
        this._nextBlock = block;
        promise.then(function(){
          return this$.emit('readable');
        });
        return this.push('');
      case 'fulfilled':
        return this.push(fn(value));
      case 'rejected':
        return this.emit('error', reason);
      default:
        return this.emit('error', new Error("Promise in invalid state: " + promise + ".state = " + state));
      }
    }
  };
  return ResolveTemplateStream;
}(Duplex));
whenHelper = function(indent, parser){
  var name, varname, render;
  name = parser.parseVariable(this.args[0]).name;
  varname = this.args.length === 3 && this.args[1] === 'as'
    ? helpers.escapeVarName(this.args[2], '_context')
    : helpers.escapeVarName(this.args[0], '_context');
  render = new Function('v', ['var _output = "";', varname + " = v;", parser.compile.call(this, indent + ""), 'return _output;'].join(''));
  return [helpers.setVar('__p', parser.parseVariable(this.args[0])), "var __n = " + JSON.stringify(name) + ";", 'var __i = ("function" === typeof __p.inspect) ? __p.inspect() : {state:"fulfilled",value:__p};', "var __render = " + render.toString() + ";", 'switch(__i.state) {', 'case "rejected": throw __i.reason;', "case 'pending': _output += _ext.promisedBlock(__p, __render, __n); break;", 'default: _output += __render(__i.value); break;', '}'].join('');
};
whenHelper.ends = true;
swig.init({
  root: __dirname + '/swigs',
  allowErrors: true,
  tags: {
    when: whenHelper,
    _t: function(indent, parser){
      var output, opts;
      output = [];
      if (this.args.length > 1) {
        opts = this.args[1];
        if (opts === 'true' || opts === 'false' || /^\{|^\[/.test(opts) || helpers.isLiteral(opts)) {
          output.push("var __opts = " + opts + ";");
        } else {
          output.push(helpers.setVar('__opts', parser.parseVariable(opts)));
        }
      }
      return output.concat([helpers.setVar('__key', parser.parseVariable(this.args[0])), '_output += _context.I18n.translate(__key, __opts);']).join('');
    },
    assetUrl: function(indent, parser){
      return [helpers.setVar('__file', parser.parseVariable(this.args[0])), '_output += __file;'].join('');
    },
    pathTo: function(indent, parser){
      return [helpers.setVar('__path', parser.parseVariable(this.args[0])), '_output += __path;'].join('');
    }
  },
  extensions: {
    promisedBlock: promisedBlock
  },
  filters: {
    pathTo: function(input){
      return input;
    },
    assetUrl: function(input){
      return input;
    },
    _t: function(input, opts){
      return input + JSON.stringify(opts);
    }
  }
});
templateInfo = {};
templates = {};
render = function(templateName, context, options){
  var template, rendered, ref$;
  context == null && (context = {});
  options == null && (options = {});
  template = templates[templateName];
  if (template == null) {
    throw new Error("Template not found: " + templateName);
  }
  rendered = template(context);
  return {
    status: (ref$ = options.status) != null ? ref$ : 200,
    headers: {
      'Content-Type': 'text/html; charset=utf-8'
    },
    body: new ResolveTemplateStream(rendered, options)
  };
};
addTemplate = function(name, template){
  templates[name] = template.compiled;
  templateInfo[name] = template;
  return template;
};
loadTemplates = function(modules){
  return modules.forEach(function(arg$){
    var name, directory, templatesPath, files;
    name = arg$.name, directory = arg$.directory;
    templatesPath = directory + "/templates/";
    files = glob.sync(templatesPath + "**/*.html");
    return files.forEach(function(filename){
      var rel, pathSegments, templateName, source, compiled;
      rel = filename.replace(templatesPath, '').replace('.html', '');
      pathSegments = [name].concat(rel.split('/'));
      if (pathSegments[pathSegments.length - 1] === 'index') {
        pathSegments.pop();
      }
      templateName = pathSegments.join('_');
      source = readFileSync(filename).toString();
      compiled = swig.compile(source, {
        filename: templateName
      });
      return addTemplate(templateName, {
        filename: filename,
        source: source,
        compiled: compiled
      });
    });
  });
};
render.addTemplate = addTemplate;
render.loadTemplates = loadTemplates;
module.exports = render;
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}