// Generated by LiveScript 1.2.0
var glob, path, readFileSync, swig, Duplex, helpers, uuid, cacheTemplates, allowTemplateErrors, templateInfo, templates, _modules, templateError, swig__compileFile, promisedBlocks, promisedBlock, ResolveTemplateStream, whenHelper, render, addTemplate, loadTemplates, slice$ = [].slice;
glob = require('glob');
path = require('path');
readFileSync = require('fs').readFileSync;
swig = require('swig');
Duplex = require('stream').Duplex;
helpers = require('swig/lib/helpers');
uuid = require('node-uuid');
cacheTemplates = false;
allowTemplateErrors = false;
templateInfo = {};
templates = {};
_modules = {};
templateError = function(error){
  return {
    render: function(){
      return "<pre>" + error.stack + "</pre>";
    }
  };
};
swig__compileFile = swig.compileFile;
swig.compileFile = function(templateName, forceAllowErrors){
  var get, e;
  templateName = templateName.replace(/\/index$/, '');
  if (cacheTemplates && templates.hasOwnProperty(templateName)) {
    return templates[templateName];
  }
  get = function(){
    var ref$, moduleName, segments, module, dirname, filename, tryFilename, err;
    ref$ = templateName.split('/'), moduleName = ref$[0], segments = slice$.call(ref$, 1);
    module = _modules[moduleName];
    if (module == null) {
      throw new Error("Unknown module: " + moduleName);
    }
    dirname = path.join.apply(path, [module.directory, 'templates'].concat(slice$.call(segments)));
    filename = dirname + '.html';
    tryFilename = function(filename){
      var compiled;
      compiled = swig__compileFile(filename, forceAllowErrors);
      addTemplate(templateName, {
        filename: filename,
        compiled: compiled
      });
      return compiled;
    };
    try {
      return tryFilename(filename);
    } catch (e$) {
      err = e$;
      if (err.code !== 'ENOENT') {
        throw err;
      }
      return tryFilename(dirname + '/index.html');
    }
  };
  if (allowTemplateErrors || forceAllowErrors) {
    return get();
  } else {
    try {
      return get();
    } catch (e$) {
      e = e$;
      return templateError(e);
    }
  }
};
promisedBlocks = {};
promisedBlock = function(promise, fn, name){
  var kindaUniq;
  kindaUniq = "<!--Q:$" + uuid.v4() + "-->";
  promisedBlocks[kindaUniq] = {
    promise: promise,
    fn: fn,
    name: name
  };
  return kindaUniq;
};
ResolveTemplateStream = (function(superclass){
  var prototype = extend$((import$(ResolveTemplateStream, superclass).displayName = 'ResolveTemplateStream', ResolveTemplateStream), superclass).prototype, constructor = ResolveTemplateStream;
  function ResolveTemplateStream(_buffer, opts){
    var ref$;
    this._buffer = _buffer;
    opts == null && (opts = {});
    this._nextBlock = null;
    this._timeout = (ref$ = opts.timeout) != null ? ref$ : 2000;
    ResolveTemplateStream.superclass.call(this, opts);
  }
  prototype._getNextBlock = function(){
    var block, markerIdx, skipped, markerEnd, marker;
    if (this._nextBlock != null) {
      block = this._nextBlock;
      this._nextBlock = null;
      return {
        skipped: '',
        block: block
      };
    } else {
      markerIdx = this._buffer.indexOf('<!--Q:$');
      if (markerIdx === -1) {
        skipped = this._buffer;
        this._buffer = '';
        return {
          skipped: skipped,
          block: null
        };
      } else {
        skipped = this._buffer.substr(0, markerIdx);
        markerEnd = this._buffer.indexOf('-->', markerIdx) + 3;
        if (markerIdx === -1) {
          throw new Error('Unclosed marker in deferred template');
        }
        marker = this._buffer.substring(markerIdx, markerEnd);
        this._buffer = this._buffer.substr(markerEnd);
        block = promisedBlocks[marker];
        if (block == null) {
          throw new Error("Invalid block id: " + marker);
        }
        return {
          skipped: skipped,
          block: block
        };
      }
    }
  };
  prototype._read = function(){
    var ref$, skipped, block, promise, fn, state, value, reason, this$ = this;
    this._timer == null && (this._timer = setTimeout(function(){
      var waitedFor, ref$, ref1$, err;
      if (this$._nextBlock != null || this$._buffer !== '') {
        waitedFor = (ref$ = (ref1$ = this$._nextBlock) != null ? ref1$.name : void 8) != null ? ref$ : '<unknown>';
        err = new Error("Rendering timed out while waiting for " + waitedFor);
        err.renderBuffer = this$._buffer;
        this$.emit('error', err);
        this$.push(null);
      }
      this$._nextBlock = null;
      return this$._buffer = '';
    }, this._timeout));
    if (this._buffer === '') {
      clearTimeout(this._timer);
      this.push(null);
    }
    ref$ = this._getNextBlock(), skipped = ref$.skipped, block = ref$.block;
    if (skipped !== '') {
      this.push(skipped);
    }
    if (block != null) {
      promise = block.promise, fn = block.fn;
      ref$ = promise.inspect(), state = ref$.state, value = ref$.value, reason = ref$.reason;
      switch (state) {
      case 'pending':
        this._nextBlock = block;
        promise.then(function(){
          return this$.emit('readable');
        });
        return this.push('');
      case 'fulfilled':
        return this.push(fn(value));
      case 'rejected':
        return this.emit('error', reason);
      default:
        return this.emit('error', new Error("Promise in invalid state: " + promise + ".state = " + state));
      }
    }
  };
  return ResolveTemplateStream;
}(Duplex));
whenHelper = function(indent, parser){
  var name, varname, render;
  name = parser.parseVariable(this.args[0]).name;
  varname = this.args.length === 3 && this.args[1] === 'as'
    ? helpers.escapeVarName(this.args[2], '_context')
    : helpers.escapeVarName(this.args[0], '_context');
  render = new Function('v', ['var _output = "";', varname + " = v;", parser.compile.call(this, indent + ""), 'return _output;'].join(''));
  return [helpers.setVar('__p', parser.parseVariable(this.args[0])), "var __n = " + JSON.stringify(name) + ";", 'var __i = ("function" === typeof __p.inspect) ? __p.inspect() : {state:"fulfilled",value:__p};', "var __render = " + render.toString() + ";", 'switch(__i.state) {', 'case "rejected": throw __i.reason;', "case 'pending': _output += _ext.promisedBlock(__p, __render, __n); break;", 'default: _output += __render(__i.value); break;', '}'].join('');
};
whenHelper.ends = true;
swig.init({
  root: __dirname + '/swigs',
  cache: cacheTemplates,
  allowErrors: true,
  tags: {
    when: whenHelper,
    assetUrl: function(indent, parser){
      return [helpers.setVar('__file', parser.parseVariable(this.args[0])), '_output += __file;'].join('');
    },
    jsUrl: function(indent, parser){
      return [helpers.setVar('__file', parser.parseVariable(this.args[0])), '_output += __file;'].join('');
    },
    pathTo: function(indent, parser){
      return [helpers.setVar('__path', parser.parseVariable(this.args[0])), '_output += __path;'].join('');
    },
    route: function(indent, parser){
      var ref$, routeStr, opts, output, log;
      ref$ = this.args, routeStr = ref$[0], opts = ref$[1];
      output = [];
      if (opts != null) {
        if (opts === 'true' || opts === 'false' || /^\{|^\[/.test(opts) || helpers.isLiteral(opts)) {
          console.log(opts);
          output.push("var __opts = " + opts + ";");
        } else {
          output.push(helpers.setVar('__opts', parser.parseVariable(opts)));
        }
      } else {
        output.push('var __opts = {};');
      }
      log = function(str){
        console.log(str);
        return str;
      };
      return output.concat([helpers.setVar('__r', parser.parseVariable(routeStr)), '_output += _context.router.reverseRoute(["GET"], __r, __opts);']).join('');
    }
  },
  extensions: {
    promisedBlock: promisedBlock
  },
  filters: {
    pathTo: function(input){
      return input;
    },
    assetUrl: function(input){
      return input;
    },
    _t: function(input, opts){
      return input + JSON.stringify(opts);
    }
  }
});
render = function(templateName, context, options){
  var template, rendered, ref$;
  context == null && (context = {});
  options == null && (options = {});
  template = swig.compileFile(templateName);
  if (template == null) {
    throw new Error("Template not found: " + templateName);
  }
  rendered = template.render(context);
  return {
    status: (ref$ = options.status) != null ? ref$ : 200,
    headers: {
      'Content-Type': 'text/html; charset=utf-8'
    },
    body: new ResolveTemplateStream(rendered, options)
  };
};
addTemplate = function(name, template){
  templates[name] = template.compiled;
  templateInfo[name] = template;
  return template;
};
loadTemplates = function(modules){
  return _modules = modules.reduce(function(acc, module){
    acc[module.name] = module;
    return acc;
  }, {});
};
render.addTemplate = addTemplate;
render.loadTemplates = loadTemplates;
module.exports = render;
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}