// Generated by LiveScript 1.2.0
var Url, querystring, Q, ConcatStream, cookie, createCipher, createDecipher, withParsedUrl, parseRequestBody, withBodyParser, withSession, patchRequest;
Url = require('url');
querystring = require('querystring');
Q = require('q');
ConcatStream = require('concat-stream');
cookie = require('cookie');
createCipher = require('crypto').createCipher;
createDecipher = require('crypto').createDecipher;
require('../vendor/connect/patch');
withParsedUrl = function(req){
  var ref$, pathname, search, query;
  ref$ = req.url.split('?'), pathname = ref$[0], search = ref$[1];
  query = querystring.parse(search);
  if (pathname.length > 1 && deepEq$(pathname[pathname.length - 1], '/', '===')) {
    pathname = pathname.substr(0, pathname.length - 1);
  }
  req.protocol = (ref$ = req.headers['x-forwarded-proto']) != null
    ? ref$
    : Object.defineProperties(req, {
      query: {
        get: function(){
          return querystring.parse(search);
        }
      },
      protocol: {
        get: function(){
          var proto, ref$;
          if (this.connection.encrypted) {
            return 'https';
          }
          proto = (ref$ = req.headers['x-forwarded-proto']) != null ? ref$ : 'http';
          return proto.split(/\s*,\s*/)[0];
        }
      },
      host: {
        get: function(){
          var host, ref$;
          host = (ref$ = req.headers['x-forwarded-host']) != null
            ? ref$
            : req.headers['host'];
          return host != null
            ? host
            : req.connection.localAddress + ":" + req.connection.localPort;
        }
      },
      absoluteUrl: {
        get: function(){
          return Url.format({
            protocol: req.protocol,
            pathname: req.pathname,
            host: req.host
          });
        }
      }
    });
  return req.pathname = pathname, req;
};
parseRequestBody = curry$(function(headers, data){
  var ref$, mime, mimeMeta;
  ref$ = (headers['content-type'] || '').split(';'), mime = ref$[0], mimeMeta = ref$[1];
  switch (mime) {
  case 'application/x-www-form-urlencoded':
    return querystring.parse(data.toString());
  default:
    throw new Error("Unsupported mime type: " + mime);
  }
});
withBodyParser = function(req){
  req.setEncoding('utf8');
  return Object.defineProperties(req, {
    body: {
      get: function(){
        var ref$;
        return (ref$ = this._bodyPromise) != null
          ? ref$
          : this._bodyPromise = function(){
            var deferred, bodyStream;
            deferred = Q.defer();
            bodyStream = new ConcatStream(bind$(deferred, 'resolve'));
            bodyStream.once('error', bind$(deferred, 'reject'));
            req.pipe(bodyStream);
            return deferred.promise;
          }();
      }
    },
    content: {
      get: function(){
        var ref$;
        return (ref$ = this._contentPromise) != null
          ? ref$
          : this._contentPromise = function(){
            return req.body.then(parseRequestBody(req.headers));
          }();
      }
    }
  });
};
withSession = function(req, res){
  var sessionSecret, tryParse, that, fromCookie, decrypted, err;
  req.secret == null && (req.secret = 'Q9kqNvTzxGiwJ2G2xGw/DJWRCYQoOnusNAiPmaWuWLCsD6nfGOycIkn4HxJYj');
  sessionSecret = new Buffer(req.secret, 'base64');
  tryParse = function(obj){
    var key, raw;
    for (key in obj) {
      raw = obj[key];
      try {
        if (0 === raw.indexOf('j:')) {
          obj[key] = JSON.parse(raw.substr(2));
        }
      } catch (e$) {}
    }
    return obj;
  };
  req.cookies = (that = req.headers.cookie)
    ? tryParse(cookie.parse(that))
    : {};
  req.session = req.cookies['quinn.session']
    ? (function(){
      try {
        fromCookie = JSON.parse(req.cookies['quinn.session']);
        decrypted = new Buffer(fromCookie.e, 'base64').toString('ascii');
        return JSON.parse(decrypted);
      } catch (e$) {
        err = e$;
        console.log(err.stack);
        return {};
      }
    }())
    : {};
  res.on('header', function(){
    var serialized, encrypted, forCookie;
    if (req.session != null) {
      serialized = JSON.stringify(req.session);
      encrypted = new Buffer(serialized, 'ascii').toString('base64');
      forCookie = JSON.stringify({
        e: encrypted
      });
      return res.setHeader('Set-Cookie', cookie.serialize('quinn.session', forCookie));
    } else {
      return res.setHeader('Set-Cookie', cookie.serialize('quinn.session', null));
    }
  });
  return req;
};
module.exports = patchRequest = function(req, res){
  withParsedUrl(req);
  withSession(req, res);
  return withBodyParser(req);
};
function deepEq$(x, y, type){
  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
      has = function (obj, key) { return hasOwnProperty.call(obj, key); };
  var first = true;
  return eq(x, y, []);
  function eq(a, b, stack) {
    var className, length, size, result, alength, blength, r, key, ref, sizeB;
    if (a == null || b == null) { return a === b; }
    if (a.__placeholder__ || b.__placeholder__) { return true; }
    if (a === b) { return a !== 0 || 1 / a == 1 / b; }
    className = toString.call(a);
    if (toString.call(b) != className) { return false; }
    switch (className) {
      case '[object String]': return a == String(b);
      case '[object Number]':
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        return +a == +b;
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') { return false; }
    length = stack.length;
    while (length--) { if (stack[length] == a) { return true; } }
    stack.push(a);
    size = 0;
    result = true;
    if (className == '[object Array]') {
      alength = a.length;
      blength = b.length;
      if (first) { 
        switch (type) {
        case '===': result = alength === blength; break;
        case '<==': result = alength <= blength; break;
        case '<<=': result = alength < blength; break;
        }
        size = alength;
        first = false;
      } else {
        result = alength === blength;
        size = alength;
      }
      if (result) {
        while (size--) {
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
        }
      }
    } else {
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
        return false;
      }
      for (key in a) {
        if (has(a, key)) {
          size++;
          if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
        }
      }
      if (result) {
        sizeB = 0;
        for (key in b) {
          if (has(b, key)) { ++sizeB; }
        }
        if (first) {
          if (type === '<<=') {
            result = size < sizeB;
          } else if (type === '<==') {
            result = size <= sizeB
          } else {
            result = size === sizeB;
          }
        } else {
          first = false;
          result = size === sizeB;
        }
      }
    }
    stack.pop();
    return result;
  }
}
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}