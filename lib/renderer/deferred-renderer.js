// Generated by LiveScript 1.2.0
var Duplex, uuid, helpers, whenHelper, promisedBlocks, promisedBlock, ResolveTemplateStream, resolvePromisedBlocks, ref$;
Duplex = require('stream').Duplex;
uuid = require('node-uuid');
helpers = require('swig/lib/helpers');
whenHelper = function(indent, parser){
  var name, varname, render;
  name = parser.parseVariable(this.args[0]).name;
  varname = this.args.length === 3 && this.args[1] === 'as'
    ? helpers.escapeVarName(this.args[2], '_context')
    : helpers.escapeVarName(this.args[0], '_context');
  render = new Function('v', ['var _output = "";', varname + " = v;", parser.compile.call(this, indent + ""), 'return _output;'].join(''));
  return [helpers.setVar('__p', parser.parseVariable(this.args[0])), "var __n = " + JSON.stringify(name) + ";", 'var __i = ("function" === typeof __p.inspect) ? __p.inspect() : {state:"fulfilled",value:__p};', "var __render = " + render.toString() + ";", 'switch(__i.state) {', 'case "rejected": throw __i.reason;', "case 'pending': _output += _ext.promisedBlock(__p, __render, __n); break;", 'default: _output += __render(__i.value); break;', '}'].join('');
};
whenHelper.ends = true;
promisedBlocks = {};
promisedBlock = function(promise, fn, name){
  var kindaUniq;
  kindaUniq = "<!--Q:$" + uuid.v4() + "-->";
  promisedBlocks[kindaUniq] = {
    promise: promise,
    fn: fn,
    name: name
  };
  return kindaUniq;
};
ResolveTemplateStream = (function(superclass){
  var prototype = extend$((import$(ResolveTemplateStream, superclass).displayName = 'ResolveTemplateStream', ResolveTemplateStream), superclass).prototype, constructor = ResolveTemplateStream;
  function ResolveTemplateStream(_buffer, opts){
    var ref$;
    this._buffer = _buffer;
    opts == null && (opts = {});
    this._nextBlock = null;
    this._timeout = (ref$ = opts.timeout) != null ? ref$ : 2000;
    ResolveTemplateStream.superclass.call(this, opts);
  }
  prototype._getNextBlock = function(){
    var block, markerIdx, skipped, markerEnd, marker;
    if (this._nextBlock != null) {
      block = this._nextBlock;
      this._nextBlock = null;
      return {
        skipped: '',
        block: block
      };
    } else {
      markerIdx = this._buffer.indexOf('<!--Q:$');
      if (markerIdx === -1) {
        skipped = this._buffer;
        this._buffer = '';
        return {
          skipped: skipped,
          block: null
        };
      } else {
        skipped = this._buffer.substr(0, markerIdx);
        markerEnd = this._buffer.indexOf('-->', markerIdx) + 3;
        if (markerIdx === -1) {
          throw new Error('Unclosed marker in deferred template');
        }
        marker = this._buffer.substring(markerIdx, markerEnd);
        this._buffer = this._buffer.substr(markerEnd);
        block = promisedBlocks[marker];
        if (block == null) {
          throw new Error("Invalid block id: " + marker);
        }
        return {
          skipped: skipped,
          block: block
        };
      }
    }
  };
  prototype._read = function(){
    var ref$, skipped, block, promise, fn, state, value, reason, evaluated, renderErr, this$ = this;
    this._timer == null && (this._timer = setTimeout(function(){
      var waitedFor, ref$, ref1$, err;
      if (this$._nextBlock != null || this$._buffer !== '') {
        waitedFor = (ref$ = (ref1$ = this$._nextBlock) != null ? ref1$.name : void 8) != null ? ref$ : '<unknown>';
        err = new Error("Rendering timed out while waiting for " + waitedFor);
        err.renderBuffer = this$._buffer;
        this$.emit('error', err);
        this$.push(null);
      }
      this$._nextBlock = null;
      return this$._buffer = '';
    }, this._timeout));
    if (this._buffer === '') {
      clearTimeout(this._timer);
      this.push(null);
    }
    ref$ = this._getNextBlock(), skipped = ref$.skipped, block = ref$.block;
    if (skipped !== '') {
      this.push(skipped);
    }
    if (block != null) {
      promise = block.promise, fn = block.fn;
      ref$ = promise.inspect(), state = ref$.state, value = ref$.value, reason = ref$.reason;
      switch (state) {
      case 'pending':
        this._nextBlock = block;
        if (!this._alreadyWaiting) {
          this._alreadyWaiting = true;
          promise.then(function(){
            return this$.read(0);
          });
          promise.fail(function(){
            return this$.read(0);
          });
        }
        return this.push('');
      case 'fulfilled':
        this._alreadyWaiting = false;
        try {
          evaluated = fn(value);
          return this.push(evaluated);
        } catch (e$) {
          renderErr = e$;
          return this.emit('error', renderErr);
        }
        break;
      case 'rejected':
        this._alreadyWaiting = false;
        return this.emit('error', reason);
      default:
        this._alreadyWaiting = false;
        return this.emit('error', new Error("Promise in invalid state: " + promise + ".state = " + state));
      }
    }
  };
  return ResolveTemplateStream;
}(Duplex));
resolvePromisedBlocks = function(rendered, options){
  return new ResolveTemplateStream(rendered, options);
};
ref$ = module.exports;
ref$.promisedBlock = promisedBlock;
ref$.resolvePromisedBlocks = resolvePromisedBlocks;
ref$.whenHelper = whenHelper;
ref$.ResolveTemplateStream = ResolveTemplateStream;
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}