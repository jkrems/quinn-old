// Generated by LiveScript 1.2.0
var path, readFileSync, _, parser, deferredRenderer, byName, TemplateError, RenderFunc, statelessSwig, slice$ = [].slice;
path = require('path');
readFileSync = require('fs').readFileSync;
_ = require('lodash');
parser = require('swig/lib/parser');
deferredRenderer = require('./deferred-renderer');
byName = function(memo, module){
  memo[module.name] = module;
  return memo;
};
TemplateError = function(error){
  return {
    render: function(){
      return "<pre>" + error.stack + "</pre>";
    }
  };
};
RenderFunc = function(code){
  return new Function('_context', '_parents', '_filters', '_', '_ext', ['_parents = _parents ? _parents.slice() : [];', '_context = _context || {};', 'var j = _parents.length,', '  _output = "",', '  _this = this;', 'while (j--) {', '   if (_parents[j] === this.id) {', '     return "Circular import of template " + this.id + " in " + _parents[_parents.length-1];', '   }', '}', '_parents.push(this.id);', code, 'return _output;'].join(''));
};
module.exports = statelessSwig = function(modules, config){
  var encoding, CACHE, promisedBlock, resolvePromisedBlocks, whenHelper, Template, getTemplate, compileFile, render;
  modules = modules.reduce(byName, {});
  encoding = 'utf8';
  CACHE = {};
  promisedBlock = deferredRenderer.promisedBlock, resolvePromisedBlocks = deferredRenderer.resolvePromisedBlocks, whenHelper = deferredRenderer.whenHelper;
  Template = function(data, id){
    var template, tokens, err, code, renderFn;
    template = {
      compileFile: compileFile,
      blocks: {},
      type: parser.TEMPLATE,
      id: id
    };
    if (!config.get('templates.displayErrors')) {
      tokens = parser.parse.call(template, data, render.tags, render.autoescape);
    } else {
      try {
        tokens = parser.parse.call(template, data, render.tags, render.autoescape);
      } catch (e$) {
        err = e$;
        return TemplateError(err);
      }
    }
    template.tokens = tokens;
    code = parser.compile.call(template);
    renderFn = code !== false
      ? RenderFunc(code)
      : function(_context, _parents, _filters, _, _ext){
        var code, fn;
        code = parser.compile.call(template, '', _context);
        fn = RenderFunc(code);
        return fn.apply(this, [_context, _parents, _filters, _, _ext]);
      };
    template.render = function(context, parents){
      var err;
      if (!config.get('templates.displayErrors')) {
        return renderFn.apply(this, [context, parents, render.filters, _, render.extensions]);
      } else {
        try {
          return renderFn.apply(this, [context, parents, render.filters, _, render.extensions]);
        } catch (e$) {
          err = e$;
          return TemplateError(err);
        }
      }
    };
    return template;
  };
  getTemplate = function(source, options){
    var id, ref$;
    id = (ref$ = options.filename) != null ? ref$ : source;
    if (config.get('templates.cache') || options.cache) {
      if (CACHE.hasOwnProperty(id)) {
        return CACHE[id];
      } else {
        return CACHE[id] = Template(source, id);
      }
    } else {
      return Template(source, id);
    }
  };
  compileFile = function(templateName, forceAllowErrors){
    var ref$, moduleName, segments, module, dirname, filenames, get, err;
    if (config.get('templates.cache') && CACHE.hasOwnProperty(templateName)) {
      return CACHE[templateName];
    }
    ref$ = templateName.split('/'), moduleName = ref$[0], segments = slice$.call(ref$, 1);
    module = modules[moduleName];
    if (module == null) {
      throw new Error("Unknown module: " + moduleName);
    }
    dirname = path.join.apply(path, [module.directory, 'templates'].concat(slice$.call(segments)));
    filenames = [dirname + ".html", dirname + "/index.html"];
    get = function(){
      var excp, tpl, getSingle, c;
      excp = tpl = void 8;
      getSingle = function(filename){
        var data, err;
        try {
          data = readFileSync(filename, encoding);
          return tpl = getTemplate(data, {
            filename: templateName
          });
        } catch (e$) {
          err = e$;
          if (!(err.code === 'ENOENT' && excp != null)) {
            return excp = err;
          }
        }
      };
      c = 0;
      while (tpl === void 8 && c < filenames.length) {
        getSingle(filenames[c++]);
      }
      if (tpl === void 8) {
        throw excp;
      }
      return tpl;
    };
    if (!config.get('templates.displayErrors') || forceAllowErrors) {
      return get();
    } else {
      try {
        return get();
      } catch (e$) {
        err = e$;
        return TemplateError(err);
      }
    }
  };
  render = function(templateName, context, options){
    var template, html, ref$;
    context == null && (context = {});
    options == null && (options = {});
    template = compileFile(templateName);
    if (template == null) {
      throw new Error("Template not found: " + templateName);
    }
    html = template.render(context);
    return {
      status: (ref$ = options.status) != null ? ref$ : 200,
      headers: {
        'Content-Type': 'text/html; charset=utf-8'
      },
      body: resolvePromisedBlocks(html, options)
    };
  };
  import$(render, {
    tags: _.clone(require('swig/lib/tags')),
    filters: _.clone(require('swig/lib/filters')),
    extensions: {
      promisedBlock: promisedBlock
    }
  });
  import$(render.tags, {
    when: whenHelper
  });
  return render;
};
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}