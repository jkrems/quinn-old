// Generated by LiveScript 1.2.0
var querystring, STATUS_CODES, EventEmitter, Q, ConcatStream, router, respond, HTTP_VERBS, defaultRoute, defaultErrorHandler, mapResult, sendTo, withParsedUrl, parseRequestBody, withBodyParser, createApp, toString$ = {}.toString;
querystring = require('querystring');
STATUS_CODES = require('http').STATUS_CODES;
EventEmitter = require('events').EventEmitter;
Q = require('q');
ConcatStream = require('concat-stream');
router = require('./router');
respond = require('./respond');
HTTP_VERBS = {
  get: ['GET', 'HEAD'],
  post: ['POST'],
  put: ['PUT'],
  patch: ['PATCH'],
  del: ['DELETE'],
  head: ['HEAD'],
  options: ['OPTIONS']
};
defaultRoute = {
  params: [],
  handler: function(arg$){
    var method, pathname;
    method = arg$.method, pathname = arg$.pathname;
    return respond.text("Cannot " + method + " " + pathname, 404);
  }
};
defaultErrorHandler = function(req, err){
  return respond.text(err.stack, 500);
};
mapResult = function(result){
  switch (toString$.call(result).slice(8, -1)) {
  case 'Function':
    return result;
  case 'String':
    return respond.text(result);
  case 'Number':
    return respond.text(STATUS_CODES[String(result)], result);
  case 'Array':
    return respond.chunks(result);
  default:
    return respond(result);
  }
};
sendTo = function(result, res){
  return result.then(mapResult).fcall(res);
};
withParsedUrl = function(req){
  var ref$, pathname, search, query;
  ref$ = req.url.split('?'), pathname = ref$[0], search = ref$[1];
  query = querystring.parse(search);
  return req.pathname = pathname, req.query = query, req;
};
parseRequestBody = curry$(function(headers, data){
  var ref$, mime, mimeMeta;
  ref$ = (headers['content-type'] || '').split(';'), mime = ref$[0], mimeMeta = ref$[1];
  switch (mime) {
  case 'application/x-www-form-urlencoded':
    return querystring.parse(data.toString());
  default:
    throw new Error("Unsupported mime type: " + mime);
  }
});
withBodyParser = function(req){
  req.setEncoding('utf8');
  return Object.defineProperties(req, {
    body: {
      get: function(){
        var ref$;
        return (ref$ = this._bodyPromise) != null
          ? ref$
          : this._bodyPromise = function(){
            var deferred, bodyStream;
            deferred = Q.defer();
            bodyStream = new ConcatStream(bind$(deferred, 'resolve'));
            bodyStream.once('error', bind$(deferred, 'reject'));
            req.pipe(bodyStream);
            return deferred.promise;
          }();
      }
    },
    content: {
      get: function(){
        var ref$;
        return (ref$ = this._contentPromise) != null
          ? ref$
          : this._contentPromise = function(){
            return req.body.then(parseRequestBody(req.headers));
          }();
      }
    }
  });
};
module.exports = createApp = function(){
  var matchRoute, pushRoute, app, i$;
  matchRoute = router();
  pushRoute = matchRoute.pushRoute;
  app = new EventEmitter();
  app.errorHandler = defaultErrorHandler;
  app.handleRequest = function(req, res){
    var lastResortResponse, ref$, handler, params, result;
    lastResortResponse = function(err){
      res.writeHead(500, {
        'Content-Type': 'text/plain'
      });
      res.end(STATUS_CODES['500']);
      return app.emit('error', err);
    };
    withParsedUrl(req);
    withBodyParser(req);
    ref$ = (ref$ = matchRoute(req)) != null ? ref$ : defaultRoute, handler = ref$.handler, params = ref$.params;
    result = Q.fcall(handler, req, params);
    return sendTo(result, res)['catch'](function(err){
      var result;
      result = Q.fcall(app.errorHandler, req, err);
      return sendTo(result, res);
    })['catch'](lastResortResponse);
  };
  for (i$ in HTTP_VERBS) {
    (fn$.call(this, i$, HTTP_VERBS[i$]));
  }
  app.all = function(routeOrRegex, stackOrHandler){
    var handler;
    handler = stackOrHandler;
    return pushRoute(routeOrRegex, handler);
  };
  return app;
  function fn$(method, verbs){
    app[method] = function(routeOrRegex, stackOrHandler){
      var handler;
      handler = stackOrHandler;
      return pushRoute(routeOrRegex, handler, verbs);
    };
  }
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}