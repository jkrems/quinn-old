// Generated by LiveScript 1.2.0
var STATUS_CODES, fs, path, EventEmitter, Q, mime, router, respond, configStore, patchIncomingRequest, statelessSwig, discoverControllers, localizedContent, services, HTTP_VERBS, defaultRoute, defaultErrorHandler, defaultHeartbeatHandler, mapResult, sendTo, createApp, slice$ = [].slice, toString$ = {}.toString;
STATUS_CODES = require('http').STATUS_CODES;
fs = require('fs');
path = require('path');
EventEmitter = require('events').EventEmitter;
Q = require('q');
mime = require('mime');
router = require('./router');
respond = require('./respond');
configStore = require('./config-store');
patchIncomingRequest = require('./patch-incoming-request');
statelessSwig = require('./renderer/stateless-swig');
discoverControllers = require('./discover-controllers');
localizedContent = require('./localized-content');
services = require('./services');
HTTP_VERBS = {
  get: ['GET', 'HEAD'],
  post: ['POST'],
  put: ['PUT'],
  patch: ['PATCH'],
  del: ['DELETE'],
  head: ['HEAD'],
  options: ['OPTIONS']
};
defaultRoute = {
  params: [],
  handler: function(arg$){
    var method, pathname, headers, quinnCtx, config, notFound, filename, _response;
    method = arg$.method, pathname = arg$.pathname, headers = arg$.headers, quinnCtx = arg$.quinnCtx;
    config = quinnCtx.config;
    notFound = function(){
      return respond.text("Cannot " + method + " " + pathname, 404);
    };
    if (method === 'GET') {
      filename = config.appPath('public', pathname);
      _response = Q.defer();
      fs.stat(filename, function(err, stats){
        var that, lastClientState, response;
        if (err != null) {
          if (err.code === 'ENOENT') {
            return _response.resolve(notFound());
          } else {
            return _response.reject(err);
          }
        }
        if ((that = headers['if-modified-since']) != null) {
          lastClientState = new Date(that);
          if (lastClientState.getTime() >= stats.mtime.getTime()) {
            return _response.resolve({
              status: 304,
              headers: {
                'Content-Type': mime.lookup(filename),
                'Last-Modified': stats.mtime.toUTCString()
              }
            });
          }
        }
        response = {
          status: 200,
          headers: {
            'Content-Type': mime.lookup(filename),
            'Last-Modified': stats.mtime.toUTCString()
          },
          body: fs.createReadStream(filename)
        };
        response.body.once('error', function(err){
          if (err.code === 'ENOENT') {
            return _response.resolve(notFound());
          } else {
            return _response.reject(err);
          }
        });
        return response.body.once('open', function(){
          return _response.resolve(response);
        });
      });
      return _response.promise;
    } else {
      return notFound();
    }
  }
};
defaultErrorHandler = function(req, err){
  var ref$, summary, trace, body;
  if (req.__isHtml) {
    ref$ = err.stack.split("\n"), summary = ref$[0], trace = slice$.call(ref$, 1);
    summary = summary.replace(/^(\w*)Error: /, '<strong>$1Error:</strong> ');
    body = "<pre>" + summary + "\n" + trace.join('\n') + "</pre>";
    return respond.text(body, 500);
  } else {
    return respond.text(err.stack, 500);
  }
};
defaultHeartbeatHandler = function(arg$, res, arg1$){
  var url, appPath, heartbeatFile;
  url = arg$.url;
  appPath = arg1$.appPath;
  if (url !== '/heartbeat') {
    return false;
  }
  heartbeatFile = appPath('public', 'heartbeat.txt');
  fs.exists(heartbeatFile, function(hasHeartbeat){
    if (hasHeartbeat) {
      return res.end('ok');
    } else {
      res.writeHead(404);
      return res.end('No public/heartbeat.txt');
    }
  });
  return true;
};
mapResult = function(result){
  switch (toString$.call(result).slice(8, -1)) {
  case 'Function':
    return result;
  case 'String':
    return respond.text(result);
  case 'Number':
    return respond.text(STATUS_CODES[String(result)], result);
  case 'Array':
    return respond.chunks(result);
  default:
    return respond(result);
  }
};
sendTo = function(result, res){
  return result.then(mapResult).fcall(res);
};
module.exports = createApp = function(){
  var pushRoute, reverseRoute, matchRoute, app, i$;
  pushRoute = reverseRoute = matchRoute = function(){
    throw new Error("Load modules before doing any routing");
  };
  app = new EventEmitter();
  app.matchRoute = matchRoute;
  app.reverseRoute = reverseRoute;
  app.config = configStore();
  app.errorHandler = defaultErrorHandler;
  app.heartbeatHandler = defaultHeartbeatHandler;
  app.handleRequest = function(req, res){
    var lastResortResponse, ref$, handler, module, action, params, result;
    if (app.heartbeatHandler(req, res, app.config)) {
      return;
    }
    lastResortResponse = function(err){
      try {
        res.writeHead(500, {
          'Content-Type': 'text/plain'
        });
      } catch (e$) {}
      try {
        res.write(STATUS_CODES['500']);
      } catch (e$) {}
      try {
        return res.end();
      } catch (e$) {}
    };
    req.quinnCtx = {
      router: matchRoute,
      config: app.config,
      render: app.render,
      service: app.service,
      i18n: app.localize(req, res)
    };
    patchIncomingRequest(req, res);
    ref$ = (ref$ = matchRoute(req)) != null ? ref$ : defaultRoute, handler = ref$.handler, module = ref$.module, action = ref$.action, params = ref$.params;
    if (module != null) {
      req.quinnCtx.i18n.scope = [module];
    }
    result = Q.fcall(handler, req, params);
    return sendTo(result, res)['catch'](function(err){
      var result;
      result = Q.fcall(app.errorHandler, req, err);
      return sendTo(result, res);
    })['catch'](lastResortResponse).done();
  };
  app.loadModules = function(moduleBase){
    var modules;
    modules = fs.readdirSync(moduleBase).map(function(name){
      return {
        name: name,
        directory: path.join(moduleBase, name)
      };
    });
    app.controller = discoverControllers(modules);
    app.render = statelessSwig(modules, app.config);
    app.localize = localizedContent(modules, app.config);
    matchRoute = router(app.controller);
    pushRoute = matchRoute.pushRoute, reverseRoute = matchRoute.reverseRoute;
  };
  app.loadServices = function(servicesConfig){
    app.service = services(servicesConfig);
  };
  app.all = function(routeOrRegex, stackOrHandler, routeParams){
    var handler;
    handler = stackOrHandler;
    return pushRoute(routeOrRegex, handler, routeParams);
  };
  for (i$ in HTTP_VERBS) {
    (fn$.call(this, i$, HTTP_VERBS[i$]));
  }
  return app;
  function fn$(method, verbs){
    app[method] = function(routeOrRegex, stackOrHandler, routeParams){
      var handler;
      handler = stackOrHandler;
      return pushRoute(routeOrRegex, handler, routeParams, verbs);
    };
  }
};