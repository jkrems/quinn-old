// Generated by LiveScript 1.2.0
var Url, controller, compileRoute, isEqual, map, reduce, addSegmentAccessor, createRoute, ANY, router, ref$, toString$ = {}.toString, slice$ = [].slice;
Url = require('url');
controller = require('./controller');
compileRoute = require('./utils/compile-route');
isEqual = require('lodash').isEqual;
map = require('lodash').map;
reduce = require('lodash').reduce;
addSegmentAccessor = function(memo, segment, index){
  memo[segment] = {
    get: function(){
      return this[index + 1];
    },
    set: function(value){
      this[index + 1] = value;
    }
  };
  return memo;
};
createRoute = function(routeOrRegex, baseRoute){
  var ref$, pattern, segments, reversePattern, accessors;
  ref$ = (function(){
    switch (toString$.call(routeOrRegex).slice(8, -1)) {
    case 'String':
      return compileRoute(routeOrRegex);
    case 'RegExp':
      return {
        pattern: routeOrRegex,
        segments: []
      };
    default:
      throw new Error("Invalid route: " + routeOrRegex);
    }
  }()), pattern = ref$.pattern, segments = ref$.segments, reversePattern = ref$.reversePattern;
  accessors = segments.reduce(addSegmentAccessor, {});
  return baseRoute.pattern = pattern, baseRoute.accessors = accessors, baseRoute.reversePattern = reversePattern, baseRoute;
};
ANY = ['ANY'];
module.exports = router = function(){
  var routes, handlerFromString, reverseRoute, matchRoute, pushRoute;
  routes = {
    ANY: []
  };
  handlerFromString = function(ctrlAction, routeParams){
    var ref$, module, action;
    ref$ = ctrlAction.split('.'), module = ref$[0], action = ref$[1];
    action == null && (action = 'index');
    return {
      module: module,
      action: action,
      handler: controller(ctrlAction, routeParams)
    };
  };
  reverseRoute = function(methods){
    methods == null && (methods = 'GET');
    return function(ctrlAction){
      var args, ref$, _module, _action, params, routesToTry, mostUsed, bestMatch, i$, len$, module, action, reversePattern, pathname, query, usedParams, e, paramHint;
      args = slice$.call(arguments, 1);
      ref$ = ctrlAction.split('.'), _module = ref$[0], _action = ref$[1];
      _action == null && (_action = 'index');
      if (methods === 'ANY' || methods == ['ANY']) {
        methods = ['GET', 'POST', 'PUT', 'PATCH'];
      } else if ('string' === typeof methods) {
        methods = [methods];
      }
      params = (function(){
        switch (args.length) {
        case 0:
          return {};
        case 1:
          return args[0];
        default:
          return args.reduce(function(memo, arg, idx){
            if (idx % 2 === 1) {
              memo[args[idx - 1]] = arg;
            }
            return memo;
          }, {});
        }
      }());
      routesToTry = (methods.concat('ANY')).map(function(method){
        return routes[method] || [];
      }).reduce(function(memo, arr){
        return memo.concat(arr);
      }, []);
      mostUsed = -1;
      bestMatch = null;
      for (i$ = 0, len$ = routesToTry.length; i$ < len$; ++i$) {
        ref$ = routesToTry[i$], module = ref$.module, action = ref$.action, reversePattern = ref$.reversePattern;
        if (reversePattern == null) {
          continue;
        }
        if (!(module === _module && action === _action)) {
          continue;
        }
        try {
          ref$ = reversePattern(params), pathname = ref$.pathname, query = ref$.query, usedParams = ref$.usedParams;
          if (usedParams.length > mostUsed) {
            bestMatch = {
              pathname: pathname,
              query: query
            };
          }
        } catch (e$) {
          e = e$;
          if (e.type !== 'missing_param') {
            throw e;
          }
        }
      }
      if (bestMatch != null) {
        return Url.format(bestMatch);
      } else {
        paramHint = Object.keys(params).length > 0 ? JSON.stringify(params) : '';
        throw new Error("No route found for " + ctrlAction + "(" + paramHint + ")");
      }
    };
  };
  matchRoute = function(arg$){
    var method, pathname, routesToTry, ref$, i$, len$, pattern, handler, module, action, accessors, params, matched, segmentMatches;
    method = arg$.method, pathname = arg$.pathname;
    routesToTry = ((ref$ = routes[method]) != null
      ? ref$
      : []).concat(routes.ANY);
    for (i$ = 0, len$ = routesToTry.length; i$ < len$; ++i$) {
      ref$ = routesToTry[i$], pattern = ref$.pattern, handler = ref$.handler, module = ref$.module, action = ref$.action, accessors = ref$.accessors;
      params = pattern.exec(pathname);
      if (!params) {
        continue;
      }
      matched = params[0], segmentMatches = slice$.call(params, 1);
      params = [matched].concat(segmentMatches.map(unescape));
      Object.defineProperties(params, accessors);
      return {
        handler: handler,
        module: module,
        action: action,
        params: params
      };
    }
    return null;
  };
  pushRoute = function(routeOrRegex, handlerOrCtrlAction, routeParams, methods){
    var ref$, handler, module, action, route;
    routeParams == null && (routeParams = {});
    methods == null && (methods = ANY);
    ref$ = (function(){
      switch (toString$.call(handlerOrCtrlAction).slice(8, -1)) {
      case 'String':
        return handlerFromString(handlerOrCtrlAction, routeParams);
      case 'Function':
        return {
          handler: handlerOrCtrlAction,
          module: null,
          action: null
        };
      default:
        throw new Error("Invalid handler type " + toString$.call(handlerOrCtrlAction).slice(8, -1) + ": " + handlerOrCtrlAction);
      }
    }()), handler = ref$.handler, module = ref$.module, action = ref$.action;
    route = createRoute(routeOrRegex, {
      handler: handler,
      module: module,
      action: action
    });
    methods.forEach(function(method){
      method = method.toUpperCase();
      if (routes[method] != null) {
        return routes[method].push(route);
      } else {
        return routes[method] = [route];
      }
    });
    return route;
  };
  return matchRoute.pushRoute = pushRoute, matchRoute.reverseRoute = reverseRoute, matchRoute;
};
ref$ = module.exports;
ref$.addSegmentAccessor = addSegmentAccessor;
ref$.createRoute = createRoute;