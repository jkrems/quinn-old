// Generated by LiveScript 1.2.0
var compileRoute, addSegmentAccessor, createRoute, ANY, router, ref$, toString$ = {}.toString;
compileRoute = require('./utils/compile-route');
addSegmentAccessor = function(memo, segment, index){
  memo[segment] = {
    get: function(){
      return this[index + 1];
    },
    set: function(value){
      this[index + 1] = value;
    }
  };
  return memo;
};
createRoute = function(routeOrRegex, handler){
  var ref$, pattern, segments;
  ref$ = (function(){
    switch (toString$.call(routeOrRegex).slice(8, -1)) {
    case 'String':
      return compileRoute(routeOrRegex);
    case 'RegExp':
      return {
        pattern: routeOrRegex,
        segments: []
      };
    default:
      throw new Error("Invalid route: " + routeOrRegex);
    }
  }()), pattern = ref$.pattern, segments = ref$.segments;
  return {
    pattern: pattern,
    handler: handler,
    accessors: segments.reduce(addSegmentAccessor, {})
  };
};
ANY = ['ANY'];
module.exports = router = function(){
  var routes, matchRoute;
  routes = {
    ANY: []
  };
  matchRoute = function(arg$){
    var method, pathname, routesToTry, ref$, i$, len$, pattern, handler, accessors, params;
    method = arg$.method, pathname = arg$.pathname;
    routesToTry = ((ref$ = routes[method]) != null
      ? ref$
      : []).concat(routes.ANY);
    for (i$ = 0, len$ = routesToTry.length; i$ < len$; ++i$) {
      ref$ = routesToTry[i$], pattern = ref$.pattern, handler = ref$.handler, accessors = ref$.accessors;
      params = pattern.exec(pathname);
      if (!params) {
        continue;
      }
      params = [].concat(params);
      Object.defineProperties(params, accessors);
      return {
        handler: handler,
        params: params
      };
    }
    return null;
  };
  return matchRoute.pushRoute = function(routeOrRegex, handler, methods){
    var route;
    methods == null && (methods = ANY);
    route = createRoute(routeOrRegex, handler);
    methods.forEach(function(method){
      method = method.toUpperCase();
      if (routes[method] != null) {
        return routes[method].push(route);
      } else {
        return routes[method] = [route];
      }
    });
    return route;
  }, matchRoute;
};
ref$ = module.exports;
ref$.addSegmentAccessor = addSegmentAccessor;
ref$.createRoute = createRoute;