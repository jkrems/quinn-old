// Generated by LiveScript 1.2.0
var controller, compileRoute, addSegmentAccessor, createRoute, ANY, router, ref$, toString$ = {}.toString, slice$ = [].slice;
controller = require('./controller');
compileRoute = require('./utils/compile-route');
addSegmentAccessor = function(memo, segment, index){
  memo[segment] = {
    get: function(){
      return this[index + 1];
    },
    set: function(value){
      this[index + 1] = value;
    }
  };
  return memo;
};
createRoute = function(routeOrRegex, baseRoute){
  var ref$, pattern, segments, accessors;
  ref$ = (function(){
    switch (toString$.call(routeOrRegex).slice(8, -1)) {
    case 'String':
      return compileRoute(routeOrRegex);
    case 'RegExp':
      return {
        pattern: routeOrRegex,
        segments: []
      };
    default:
      throw new Error("Invalid route: " + routeOrRegex);
    }
  }()), pattern = ref$.pattern, segments = ref$.segments;
  accessors = segments.reduce(addSegmentAccessor, {});
  return baseRoute.pattern = pattern, baseRoute.accessors = accessors, baseRoute;
};
ANY = ['ANY'];
module.exports = router = function(){
  var routes, handlerFromString, reverseRoute, matchRoute;
  routes = {
    ANY: []
  };
  handlerFromString = function(ctrlAction, routeParams){
    var ref$, module, action;
    ref$ = ctrlAction.split('#'), module = ref$[0], action = ref$[1];
    action == null && (action = 'index');
    return {
      module: module,
      action: action,
      handler: controller(ctrlAction, routeParams)
    };
  };
  reverseRoute = function(method, ctrlAction){
    var params, routesToTry, ref$, i$, len$, route, results$ = [];
    params = slice$.call(arguments, 2);
    routesToTry = ((ref$ = routes[method]) != null
      ? ref$
      : []).concat(routes.ANY);
    for (i$ = 0, len$ = routesToTry.length; i$ < len$; ++i$) {
      route = routesToTry[i$];
      results$.push(console.log(route));
    }
    return results$;
  };
  matchRoute = function(arg$){
    var method, pathname, routesToTry, ref$, i$, len$, pattern, handler, module, action, accessors, params, matched, segmentMatches;
    method = arg$.method, pathname = arg$.pathname;
    routesToTry = ((ref$ = routes[method]) != null
      ? ref$
      : []).concat(routes.ANY);
    for (i$ = 0, len$ = routesToTry.length; i$ < len$; ++i$) {
      ref$ = routesToTry[i$], pattern = ref$.pattern, handler = ref$.handler, module = ref$.module, action = ref$.action, accessors = ref$.accessors;
      params = pattern.exec(pathname);
      if (!params) {
        continue;
      }
      matched = params[0], segmentMatches = slice$.call(params, 1);
      params = [matched].concat(segmentMatches.map(unescape));
      Object.defineProperties(params, accessors);
      return {
        handler: handler,
        module: module,
        action: action,
        params: params
      };
    }
    return null;
  };
  return matchRoute.pushRoute = function(routeOrRegex, handlerOrCtrlAction, routeParams, methods){
    var ref$, handler, module, action, route;
    routeParams == null && (routeParams = {});
    methods == null && (methods = ANY);
    ref$ = (function(){
      switch (toString$.call(handlerOrCtrlAction).slice(8, -1)) {
      case 'String':
        return handlerFromString(handlerOrCtrlAction, routeParams);
      case 'Function':
        return {
          handler: handlerOrCtrlAction,
          module: null,
          action: null
        };
      default:
        throw new Error("Invalid handler type " + toString$.call(handlerOrCtrlAction).slice(8, -1) + ": " + handlerOrCtrlAction);
      }
    }()), handler = ref$.handler, module = ref$.module, action = ref$.action;
    route = createRoute(routeOrRegex, {
      handler: handler,
      module: module,
      action: action
    });
    methods.forEach(function(method){
      method = method.toUpperCase();
      if (routes[method] != null) {
        return routes[method].push(route);
      } else {
        return routes[method] = [route];
      }
    });
    return route;
  }, matchRoute;
};
ref$ = module.exports;
ref$.addSegmentAccessor = addSegmentAccessor;
ref$.createRoute = createRoute;